#!/bin/bash

### Configuration
# Some of my configurations stuff here...
EDITOR="vim"
PAGER="less"

export EDITOR="$EDITOR"

# For longer commands this is useful sometimes
miniprompt() {
        PS1='$ '
}

# Finally make prompt

PROMPT='\[\033[01;32m\]\u\[\033[01;34m\]::\[\033[01;31m\]\h \[\033[00;34m\]{ \[\033[01;34m\]\w \[\033[00;34m\]}\[\033[01;32m\]-> \[\033[00m\]'
PS1="${PROMPT}"

### Aliases
# List directory contents
alias sl=ls
#alias ls='ls -G' # Compact view, show colors
alias la='ls -AF' # Compact view, show hidden
alias ll='ls -al'
alias l='ls -lah'
alias c='clear'
alias k='clear'
alias q="exit"
alias h='history'

alias editor="$EDITOR"
alias pager="$PAGER"

alias ..='cd ..' # Go up one directory
alias ...='cd ../..' # Go up two directories
alias -- -="cd -" # Go back

#git (own)

alias gmnff='git merge --no-ff'
alias gmff='git merge --ff'

# Tree
alias tree-bash="find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'"

# Directory
alias md='mkdir -p'
alias rd=rmdir
alias d='dirs -v'

# lazyness ftw
alias reload='source ~/.bashrc'
alias ducks='du -cks * | sort -rn | head -11 '
alias xmod='chmod +x'
alias timestamp='date "+%Y%m%dT%H%M%S"'
alias whereami='echo "$( hostname --fqdn ) ($(hostname -i)):$( pwd )"' # Complement to whoami command.

### History - made right.
# history length
HISTSIZE=10000
HISTFILESIZE=10000

# don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

# setting up timestamp for history
HISTTIMEFORMAT="%F %T "

# Reverse History
function rh {
  history | awk '{a[$4]++}END{for(i in a){print a[i] " " i}}' | sort -rn | head
}

# append to the history file, don't overwrite it
shopt -s histappend

##########################################################
# Git Teil
##########################################################
alias git_us='LANG=en_US git'

RED="\[\033[0;31m\]"
YELLOW="\[\033[0;33m\]"
GREEN="\[\033[0;32m\]"
BLUE="\[\033[0;34m\]"
LIGHT_RED="\[\033[1;31m\]"
LIGHT_GREEN="\[\033[1;32m\]"
WHITE="\[\033[1;37m\]"
LIGHT_GRAY="\[\033[0;37m\]"
COLOR_NONE="\[\e[0m\]"

function parse_git_branchh {
  git_us rev-parse --git-dir &> /dev/null
  git_status="$(git_us status 2> /dev/null)"
  branch_pattern="^# On branch ([^${IFS}]*)"
  detached_branch_pattern="# HEAD detached at"
  remote_pattern="# Your branch is (.*) of"
  diverge_pattern="# Your branch and (.*) have diverged"

  if [[ ${git_status}} =~ "Changed but not updated" ]]; then
    state="${RED}⚡"
  fi
  # add an else if or two here if you want to get more specific
  if [[ ${git_status} =~ ${remote_pattern} ]]; then
    if [[ ${BASH_REMATCH[1]} == "ahead" ]]; then
      remote="${YELLOW}↑"
    else
      remote="${YELLOW}↓"
    fi
  fi

  if [[ ${git_status} =~ ${diverge_pattern} ]]; then
    remote="${YELLOW}↕"
  fi

  if [[ ${git_status} =~ ${branch_pattern} ]]; then
    branch=${BASH_REMATCH[1]}
  elif [[ ${git_status} =~ ${detached_branch_pattern} ]]; then
    branch="${YELLOW}NO BRANCH ${LIGHT_RED}($(echo ${git_status} | cut -d " " -f 5))${COLOR_NONE}"
  fi

  if [[ ${#state} -gt "0" || ${#remote} -gt "0" ]]; then
    s=" "
  fi

  echo "${branch}${s}${remote}${state}"
}

function prompt_func() {
  git rev-parse --git-dir > /dev/null 2>&1

  if [ $? -eq 0 ]; then
    GITPS1="${TITLEBAR}${BLUE}[${GREEN}$(parse_git_branchh)${BLUE}]${COLOR_NONE} "
    PS1="${PROMPT}${GITPS1}"
  else
    PS1=$PSAVE
  fi
}

export PSAVE=$PS1

PROMPT_COMMAND=prompt_func
